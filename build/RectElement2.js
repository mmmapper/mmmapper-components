
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, g as getContext, P as PIXI_CONTEXT, D as DragManager, o as onDestroy, e as PIXI, W as WarpContainer, n as noop } from './main2.js';

/* ../src/elements/RectElement.svelte generated by Svelte v3.31.0 */

function create_fragment(ctx) {
	const block = {
		c: noop,
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getTransform(position, scale, obj, width, height) {
	let transform = () => {
		
	};

	if (position === "center") {
		transform = () => {
			obj.setTransform((1 + width - width * scale) / 2, (1 + height - height * scale) / 2, scale, scale);
		};
	} else if (position === "bottom") {
		transform = () => {
			obj.setTransform(0, height - height * scale, 1, scale);
		};
	}

	return transform;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("RectElement", slots, []);

	let { x = 0 } = $$props,
		{ y = 0 } = $$props,
		{ offset = [] } = $$props,
		{ width } = $$props,
		{ height } = $$props,
		{ fill = 16777215 } = $$props,
		{ brightness = null } = $$props,
		{ filters = [] } = $$props,
		{ scale = 1 } = $$props,
		{ position = "center" } = $$props,
		{ lineWidth = null } = $$props,
		{ lineColor = null } = $$props;

	const { getApp, pixiStore } = getContext(PIXI_CONTEXT);
	const app = getApp();
	const dragManager = new DragManager();
	let container, showHelper = false;
	let rect;

	pixiStore.editMode.subscribe(value => {
		showHelper = value;
		!!container && container.showHelper(value);
	});

	function setup() {
		let bg = new PIXI.Graphics();

		if (lineWidth) {
			bg.lineStyle(lineWidth, lineColor);
			bg.drawRect(0, 0, width, height);
		}

		rect = new PIXI.Graphics();
		rect.lineStyle(0);
		rect.beginFill(fill, 1).drawRect(0, 0, width, height).endFill();
		rect.filters = filters;
		bg.addChild(rect);
		container = new WarpContainer(bg, app.renderer, app.screen, showHelper);
		container.x = x;
		container.y = y;
		container.setOffset(...offset);
		dragManager.makeDraggable(container.group, container.sprite);
		app.stage.addChild(container.group);
		const transform = getTransform(position, scale, rect, width, height);
		let r, g, b;

		const update = () => {
			container.update();
			transform();

			if (brightness) {
				r = Math.ceil((fill >> 16) * brightness);
				g = Math.ceil((fill >> 8 & 255) * brightness);
				b = Math.ceil((fill & 255) * brightness);
				rect.tint = (1 << 24) + (r << 16) + (g << 8) + b & 16777215;
			}
		};

		app.ticker.add(update);

		onDestroy(() => {
			app.ticker.remove(update);
		});
	}

	setup();

	const writable_props = [
		"x",
		"y",
		"offset",
		"width",
		"height",
		"fill",
		"brightness",
		"filters",
		"scale",
		"position",
		"lineWidth",
		"lineColor"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RectElement> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("x" in $$props) $$invalidate(0, x = $$props.x);
		if ("y" in $$props) $$invalidate(1, y = $$props.y);
		if ("offset" in $$props) $$invalidate(2, offset = $$props.offset);
		if ("width" in $$props) $$invalidate(3, width = $$props.width);
		if ("height" in $$props) $$invalidate(4, height = $$props.height);
		if ("fill" in $$props) $$invalidate(5, fill = $$props.fill);
		if ("brightness" in $$props) $$invalidate(6, brightness = $$props.brightness);
		if ("filters" in $$props) $$invalidate(7, filters = $$props.filters);
		if ("scale" in $$props) $$invalidate(8, scale = $$props.scale);
		if ("position" in $$props) $$invalidate(9, position = $$props.position);
		if ("lineWidth" in $$props) $$invalidate(10, lineWidth = $$props.lineWidth);
		if ("lineColor" in $$props) $$invalidate(11, lineColor = $$props.lineColor);
	};

	$$self.$capture_state = () => ({
		getContext,
		onDestroy,
		PIXI,
		PIXI_CONTEXT,
		DragManager,
		WarpContainer,
		x,
		y,
		offset,
		width,
		height,
		fill,
		brightness,
		filters,
		scale,
		position,
		lineWidth,
		lineColor,
		getApp,
		pixiStore,
		app,
		dragManager,
		getTransform,
		container,
		showHelper,
		rect,
		setup
	});

	$$self.$inject_state = $$props => {
		if ("x" in $$props) $$invalidate(0, x = $$props.x);
		if ("y" in $$props) $$invalidate(1, y = $$props.y);
		if ("offset" in $$props) $$invalidate(2, offset = $$props.offset);
		if ("width" in $$props) $$invalidate(3, width = $$props.width);
		if ("height" in $$props) $$invalidate(4, height = $$props.height);
		if ("fill" in $$props) $$invalidate(5, fill = $$props.fill);
		if ("brightness" in $$props) $$invalidate(6, brightness = $$props.brightness);
		if ("filters" in $$props) $$invalidate(7, filters = $$props.filters);
		if ("scale" in $$props) $$invalidate(8, scale = $$props.scale);
		if ("position" in $$props) $$invalidate(9, position = $$props.position);
		if ("lineWidth" in $$props) $$invalidate(10, lineWidth = $$props.lineWidth);
		if ("lineColor" in $$props) $$invalidate(11, lineColor = $$props.lineColor);
		if ("container" in $$props) container = $$props.container;
		if ("showHelper" in $$props) showHelper = $$props.showHelper;
		if ("rect" in $$props) rect = $$props.rect;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		x,
		y,
		offset,
		width,
		height,
		fill,
		brightness,
		filters,
		scale,
		position,
		lineWidth,
		lineColor
	];
}

class RectElement extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			x: 0,
			y: 1,
			offset: 2,
			width: 3,
			height: 4,
			fill: 5,
			brightness: 6,
			filters: 7,
			scale: 8,
			position: 9,
			lineWidth: 10,
			lineColor: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RectElement",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*width*/ ctx[3] === undefined && !("width" in props)) {
			console.warn("<RectElement> was created without expected prop 'width'");
		}

		if (/*height*/ ctx[4] === undefined && !("height" in props)) {
			console.warn("<RectElement> was created without expected prop 'height'");
		}
	}

	get x() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set x(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get y() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set y(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get offset() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set offset(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get brightness() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brightness(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filters() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filters(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scale() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lineWidth() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lineWidth(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lineColor() {
		throw new Error("<RectElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lineColor(value) {
		throw new Error("<RectElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { RectElement as R };
//# sourceMappingURL=RectElement2.js.map
